# Social_chronicle

## Idea
>[!NOTE]
> I came up with the challenge idea because I wanted to use the Wayback Machine to take a snapshot of a website and then replace it with a new HTML page. This way, users would need to use the Wayback Machine to find the old version. We already had a domain that we could use for this. However, relying only on the Wayback Machine felt a bit too basic.But then I remembered something from the Huntress CTF, where Discord Snowflakes were used to access a Discord server using only the ID.

### How do Discord Snowflakes work?

Discord Snowflakes are unique identifiers generated by the Discord platform to assign a distinct identity to various entities, such as users, channels, and messages. These 64-bit numerical IDs are composed of specific components that include timestamps, internal machine IDs, and process IDs. By leveraging this intricate system, Discord ensures the creation of globally unique Snowflakes, enabling precise identification and organization of data within the platform's vast and dynamic ecosystem.
But they can also be used to convert a server ID into a server invite.

To obtain the ID from a Discord server, simply right-click on the name and click on "Copy Server ID":

![image](https://github.com/CTF-Citadel/challenges/assets/115781703/ee33f263-a8c7-4797-805c-c221f2337a93)

The same works with channel and message IDs. It's important to note that when you have a chain of Discord Snowflakes, the first one is the Server ID, the second is the Channel ID, and the last is the Message ID. For example:
1121776392359649290 (Server ID) /1128293428078317568 (Channel ID) /1128294401865678969 (Message ID)

So, we created a simple Discord server, and I copied the IDs from there. While the only important thing is the Server ID, the Discord setup looks like this:

![image](https://github.com/CTF-Citadel/challenges/assets/115781703/0a95c5aa-ff85-492c-b068-aec8c75ac284)

### Wayback Machine

Now that I have my Discord Snowflake ready, I had to create a simple HTML page that looks like a blog post, including some information. It goes along with the AI theme and also adds a little joke to another challenge, but most importantly, it includes my Discord IDs. The code for the HTML page uses inline CSS to make it more simple.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Blog Post</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f4f4f4;
        }

        .blog-post {
            max-width: 600px;
            width: 100%;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
        }

        p {
            color: #666;
        }

        .author-info {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>

<div class="blog-post">
    <h1>Coding the Future: AI for Image Creation</h1>
    <p><em>Published on January 11, 2024</em></p>
    
    <p>As I sit down to write this blog post, lines of code dance across my screen, bringing to life an exciting venture: developing an AI for image creation. The challenge is exhilarating, as I explore the realms of neural networks and deep learning.</p>

    <p>The idea sprouted from a passion for merging technology and art. I envision a future where AI aids in crafting breathtaking visuals, pushing the boundaries of creativity. The journey, however, is not without its hurdles, and the fear of intellectual property theft lingers in the back of my mind.</p>

    <p>Every line of code feels like a brushstroke on a digital canvas, and with each iteration, the AI evolves. I tread carefully, implementing security measures to safeguard my creation. The thrill of innovation is tempered by the responsibility to protect the fruits of labor.</p>
     
    <p>I just hope no one wants to steal my code and present it as their own. I've noticed an account on Instagram that I am suspecting is using my AI.</p>
   
    <p>Anyway, if you want to find out more about my AI and how it works, make sure to join here: 1121776392359649290/1121776392833597552/1122243012668424222</p>

    <div class="author-info">Written by: LostInThought</div>
</div>

</body>
</html>
```

The blog post looked like this:

![image](https://github.com/CTF-Citadel/challenges/assets/115781703/41281dad-5067-4971-9e16-e96b1b90fdd9)

The important part is the last sentence: "Anyway, if you want to find out more about my AI and how it works, make sure to join here: 1121776392359649290/1121776392833597552/1122243012668424222," including our Discord IDs.

So now I had to take a snapshot of the website on the Wayback Machine. If your domain has never been captured in a snapshot, it works with four simple steps:

1. Go to the Wayback Machine website at https://web.archive.org/.

2. Enter the URL:
In the "Save Page Now" box, enter the URL of the domain you want to snapshot.

3. Click the "Save Page" button.

4. Wait for Processing:
The Wayback Machine will process the request, and you'll be redirected to the archived page once it's complete.


After processing, it looks like this:

![image](https://github.com/CTF-Citadel/challenges/assets/115781703/0da93474-2005-46a8-b00f-e042720db8b2)

So after the Snapshot was done i had to overwrite the previous HTML page with a new one including no helpful information so i went with this one:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Blog Post</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f4f4f4;
        }

        .blog-post {
            max-width: 600px;
            width: 100%;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
        }

        p {
            color: #666;
        }

        .author-info {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>

<div class="blog-post">
    <h1>Nothing to see here</h1>
    <p><em>Published on March 30, 2023</em></p>
    
    <p>You need to search somewhere else for the information.</p>
 

    <div class="author-info">Written by: Unknown</div>
</div>

</body>
</html>
```

It looked like this when it was done:

![image](https://github.com/CTF-Citadel/challenges/assets/115781703/0059325d-aa62-4fca-9401-05fc0aa3391d)


### Discord-Bot

The discord bot was built using python and some simple docker logic to host it anywhere in case of failure on 1 system. <br/>
It is important to note that the discord bot in this challenge although it is a central service which is accessed by multiple users does also provide dynamic flags. <br/>

The `docker-compose.yml` file below sets up 2 containers for the challenge. <br/>
1 container for the discord bot and 1 container to store users and map flags to each new user (No critical data from user is saved, pls believe me ;'{ ). <br/>
```yml
version: '3.9'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      DC_TOKEN: ${DC_TOKEN}
      DB_NAME: users
      DB_USER: dbadmin
      DB_PW: eEGnsF5JrDFfNB88LMxR
    restart: unless-stopped

  db:
    image: mariadb:latest
    hostname: db
    restart: unless-stopped
    environment:
      MARIADB_ROOT_PASSWORD: 2U3Qps4cDZHJJT8LgnJR
      MARIADB_DATABASE: users
      MARIADB_USER: dbadmin
      MARIADB_PASSWORD: eEGnsF5JrDFfNB88LMxR
```

The passwords are hardcoded because it doesn't matter as this application is only being hosted locally. <br/>
Users stored in database with following schema: 
```py
class User(Base):

    __tablename__ = "user_info"

    id = Column(String(length=255), primary_key=True)
    name = Column(String(length=255))
    flag = Column(String(length=255))

    def __repr__(self):
        return f'User(id={self.id}, name={self.name}, flag={self.flag})'
```

For the database connection I used `SQL-Alchemy`. <br/>
```py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os

db_user = os.environ.get("DB_USER")
db_password = os.environ.get("DB_PW")
db_name = os.environ.get("DB_NAME")

SQLALCHEMY_DB_URL = f'mariadb+pymysql://{db_user}:{db_password}@db:3306/{db_name}'

engine = create_engine(SQLALCHEMY_DB_URL, echo=True)
DBSession = sessionmaker(engine, autoflush=False)
```

Mapping flags to users:
```py
if message.author == bot.user:
        return

    users = db.query(models.User).filter(models.User.name == message.author).all() # check if user already exists in db

    if users:
        pass
    else:
        new_flag = ''
        for flag in open('flags.txt', 'r'):
            flags = db.query(models.User).filter(models.User.flag == flag.strip()).all() # check if flag has already been used (make sure its unique)

            if flags:
                pass
            else:
                new_flag = flag.split()
                break

        new_user = models.User( # create the new user locally
            id=message.author.id, name=message.author.name, flag=new_flag
        )
        db.add(new_user) 
        db.commit()
        db.refresh(new_user)
        db.close()
        print(f"Added new user: {message.author.name}")
```

Now this code checks if the user writes the discord bot for the first time. <br/>
If this is the case the bot makes a database entry with user_id, name and unique flag. <br/>

The actual challenge where the user is being asked three different cyber-security questions can be seen below. <br/>
```py
    for word in words:
        if word.lower() == "password" or word.lower() == "passwort":
            encrypted_text = caesar_cipher("I am a vigilant guardian, shielding networks from danger. Intruders test my defenses, but I swiftly sound the alarm. I scrutinize data flow, sieving out the malevolent. With my protective measures, safety is assured. What am I?", 2)
            
            async with message.channel.typing():
                await message.channel.send(f"```{encrypted_text}```")

            response_sent = True
            break

        elif word.lower() == "firewall":
            encrypted_text = caesar_cipher("I lurk in the shadows, unseen and unknown. Exploiting weaknesses, my presence is never shown. I infiltrate networks, spreading like a plague. A malicious force, causing havoc at my stage. What am I?", 1)
            
            async with message.channel.typing():
                await message.channel.send(f"```{encrypted_text}```")

            response_sent = True
            break

        elif word.lower() == "malware":
            async with message.channel.typing():
                await message.channel.send(f"```Congratulations, the flag is:\nTH{{{db.query(models.User.flag).filter(models.User.name == message.author.name).scalar()}}}```")
            
            response_sent = True
```

Those are three simple if cases which check for correct answers on the questions. <br/>
If they are answered correctly the user obtains the flag which was mapped to the user on initiation. <br/>